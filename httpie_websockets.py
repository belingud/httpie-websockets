import io
import platform
import queue
import ssl
import sys
import threading
import time
from pathlib import Path
from typing import Any, AnyStr, Mapping, Optional
from urllib.parse import urlparse

import websocket
from httpie.client import DEFAULT_UA
from httpie.plugins import TransportPlugin
from httpie.ssl_ import HTTPieCertificate
from requests.adapters import BaseAdapter
from requests.models import PreparedRequest, Response
from requests.structures import CaseInsensitiveDict

__version__ = "0.4.0"
__author__ = "belingud"
__license__ = "MIT"

from websocket import STATUS_ABNORMAL_CLOSED

if platform.system().lower() == "windows":
    import msvcrt

    def _read_stdin():
        if msvcrt.kbhit():
            input_buffer = ""
            while True:
                char = msvcrt.getwche()
                if char == "\r":  # Enter key
                    print()
                    break
                input_buffer += char
            return input_buffer.strip()
        return None
else:
    import select

    def _read_stdin():
        r, _, _ = select.select([sys.stdin], [], [], 1)
        if sys.stdin in r:
            return sys.stdin.readline().strip()
        return None


class AdapterError(Exception):
    """Custom exception for adapter errors."""

    def __init__(self, code: int, msg: str) -> None:
        self.code = code
        self.msg = msg

    def __str__(self) -> str:
        return f"{self.code}: {self.msg}"


class WebsocketAdapter(BaseAdapter):
    """Adapter for handling WebSocket connections."""

    ssl_version_map = {
        "ssl2.3": "SSLv23",
        "tls1": "TLSv1",
        "tls1.1": "TLSv1.1",
        "tls1.2": "TLSv1.2",
    }

    def __init__(self, queue_size: int = 1024):
        super().__init__()
        self._msg_queue = queue.Queue(maxsize=queue_size)
        self._running = False

        self._ws: Optional[websocket.WebSocket] = None
        self._ws_thread = threading.Thread(target=self._run, name="WSThread")
        self._stdout = sys.stdout
        self._stdout_lock = threading.Lock()

    def convert2ws_headers(self, headers: Mapping) -> list[str]:
        """Convert HTTP headers to WebSocket headers.

        Args:
            headers (Mapping): HTTP headers.

        Returns:
            list[str]: WebSocket headers.
        """
        if not headers:
            return []
        headers = dict(headers)
        ws_headers = []

        # Below headers already generated by websocket in handshake => _get_handshake_headers
        # https://github.com/websocket-client/websocket-client/blob/master/websocket/_handshake.py#L83
        ignore_keys = [
            "Upgrade",
            "Connection",
            "Origin",
            "Host",
            "Sec-WebSocket-Key",
            "Sec-WebSocket-Version",
        ]
        for k, v in headers.items():
            k = k.title()
            if k not in ignore_keys:
                if isinstance(v, bytes):
                    v = v.decode("utf-8")
                ws_headers.append(f"{k}: {v}")
        ws_headers.append(f"User-Agent: {headers.get('User-Agent', DEFAULT_UA)}")
        return ws_headers

    def _connect(self, request: PreparedRequest, **kwargs) -> None:
        """Connect to the WebSocket if not already connected.

        Args:
            request (PreparedRequest): The request object.
            **kwargs: Additional keyword arguments.
        """
        if self._ws and self._ws.connected:
            return
        options: dict[str, Any] = {}

        proxy = kwargs.get("proxies")
        print(f"proxies: {proxy}")
        if proxy:
            idx = 0
            ignored = []
            proxy_url = None
            for scheme, host_port in proxy.items():
                if idx > 0:
                    ignored.append(f"{scheme}://{host_port}")
                    continue
                proxy_url = urlparse(scheme + "://" + host_port)
                options["http_proxy_host"] = f"{proxy_url.scheme}://{proxy_url.hostname}"
                options["http_proxy_port"] = proxy_url.port
                idx += 1
            if ignored:
                msg = "\033[93mWarning: "
                if proxy_url:
                    msg += f"Using proxy {proxy_url.geturl()}, "
                msg += f"Proxy {', '.join(ignored)} is ignored because multiple proxies are not supported.\033[0m"
                self._write_stdout(msg)

        # --verify=yes/no
        verify = kwargs.get("verify", True)
        # IMPORTANT: httpie plugin not support specify ssl version and ciphers
        cert: Optional[HTTPieCertificate] = kwargs.get("cert")
        if not verify:
            options["sslopt"] = {"cert_reqs": ssl.CERT_NONE}
            if cert:
                self._write_stdout(
                    "\033[93mWarning: --cert is ignored because --verify is disabled.\033[0m"
                )
        else:
            if isinstance(cert, HTTPieCertificate):
                options["keyfile"] = Path(cert.key_file).expanduser().resolve().as_posix()
                options["certfile"] = Path(cert.cert_file).expanduser().resolve().as_posix()
                options["password"] = cert.key_password
            elif isinstance(cert, str):
                options["sslopt"] = {
                    "cert_reqs": ssl.CERT_REQUIRED,
                    "ca_certs": Path(cert).expanduser().resolve().as_posix(),
                }

        try:
            self._ws = websocket.WebSocket(sslopt=options.get("sslopt"))
            self._ws.connect(
                request.url,
                header=self.convert2ws_headers(request.headers),
                redirect_limit=30,  # HTTPie default
                http_proxy_host=options.get("http_proxy_host"),
                http_proxy_port=options.get("http_proxy_port"),
                keyfile=options.get("keyfile"),
                certfile=options.get("certfile"),
                password=options.get("password"),
            )
        except (websocket.WebSocketException, OSError) as e:
            raise AdapterError(500, f"Cannot connect to websocket: {str(e)}") from None

    def _receive(self):
        """Receive messages from the WebSocket."""
        while self._running:
            try:
                message = self._ws.recv()
                self._write_stdout(message)
            except websocket.WebSocketConnectionClosedException as e:
                self._write_stdout(f"Connection closed: {str(e)}")
                break
            except OSError:
                break

    def _send_messages(self):
        """Send messages to the WebSocket."""
        while self._running:
            if not self._msg_queue:
                continue
            message = self._msg_queue.get()
            if message is None:
                break
            try:
                self._ws.send(message)
            except websocket.WebSocketConnectionClosedException as e:
                self._write_stdout(f"Connection closed: {str(e)}")
                break
            except websocket.WebSocketTimeoutException as e:
                self._write_stdout(f"WebSocketTimeoutException: {str(e)}")
                continue
            except Exception as e:
                self._write_stdout(f"Error: {str(e)}")
                break

    def _run(self):
        """Run the WebSocket communication."""
        try:
            self._receive()
        except Exception as e:
            self._write_stdout(f"Error: {str(e)}")

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None, **kwargs
    ):
        """Send a request to the WebSocket.

        Args:
            request (PreparedRequest): The request object.
            stream (bool): Whether to stream the response.
            timeout (float): The timeout in seconds.
            verify (bool): Whether to verify the SSL certificate.
            cert (Union[HTTPieCertificate, str]): The path to the SSL certificate.
            proxies (dict): The proxies to use.
            **kwargs: Additional keyword arguments.

        Returns:
            Response: The response object.
        """
        self._running = True
        print(
            f">??????????????????{cert}, verify: {verify}, proxy: {proxies}, timeout: {timeout}, kwargs: {kwargs}"
        )

        try:
            self._connect(
                request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies
            )
        except AdapterError as e:
            self.close()
            return self.dummy_response(request, e.code, e.msg)

        self._ws_thread.start()
        time.sleep(0.2)
        self._write_stdout(
            f"> Connected to {request.url}\n"
            "Type a message and press enter to send it\n"
            "Press Ctrl+C to close the connection"
        )

        try:
            while self._running and self._ws.connected:
                msg = _read_stdin()
                if not msg:
                    continue
                if not self._running or not self._ws.connected:
                    self._write_stdout("Websocket closed, message not sent")
                    break
                self._ws.send_text(msg)
        except KeyboardInterrupt:
            self._write_stdout("\nKeyboardInterrupt received. Cleaning up...")
        finally:
            self.close()

        return self.dummy_response(request)

    def _write_stdout(self, msg: AnyStr, newline: bool = True) -> None:
        """Write message to stdout."""
        if not self._running:
            return
        with self._stdout_lock:
            self._stdout.write(msg)
            if newline:
                self._stdout.write("\n")
            self._stdout.flush()

    def dummy_response(
        self, request: PreparedRequest, status_code: int = 200, msg: str = ""
    ) -> Response:
        """Create a dummy response for requests send method."""
        r = Response()
        r.status_code = status_code
        r.request = request
        r.reason = msg
        r.headers = CaseInsensitiveDict(self._ws.getheaders())
        r._content = msg.encode("utf8") if msg else b""
        r.raw = io.BytesIO(
            msg.encode("utf8")
            if msg
            else (
                f"Status: {self._ws.getstatus()}\nSubprotocol: {self._ws.getsubprotocol() or ''}".encode(
                    "utf8"
                )
            )
        )
        r.encoding = "utf-8"
        r.url = request.url
        return r

    def close(self) -> None:
        """Close the WebSocket connection and clean up resources."""
        if self._running is False:
            return
        self._running = False
        if self._ws and self._ws.connected:
            self._ws.close(status=STATUS_ABNORMAL_CLOSED, reason=b"Connection closed by user")
        if self._ws_thread.is_alive():
            self._ws_thread.join()


class BaseWebsocketPlugin(TransportPlugin):
    """Base class for WebSocket transport plugins."""

    package_name = "httpie_websockets"
    description = "WebSocket transport plugin for HTTPie"

    def get_adapter(self) -> WebsocketAdapter:
        return WebsocketAdapter()


class WebsocketPlugin(BaseWebsocketPlugin):
    """Plugin for handling WebSocket connections over HTTP."""

    name = "websocket"
    prefix = "ws://"


class WebsocketSPlugin(BaseWebsocketPlugin):
    """Plugin for handling secure WebSocket connections over HTTPS."""

    name = "websocket-s"
    prefix = "wss://"


if __name__ == "__main__":
    import argparse
    import requests

    parser = argparse.ArgumentParser(prog="python -m httpie_websocket")
    parser.add_argument("url")
    args = parser.parse_args()

    adapter = WebsocketAdapter()
    session = requests.Session()
    session.mount("ws://", adapter)
    session.mount("wss://", adapter)
    resp = session.request("WEBSOCKET", args.url)
    print(resp.text)
    session.close()
